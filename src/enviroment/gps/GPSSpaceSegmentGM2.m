classdef GPSPseudorangeGM2 < GPS
    % Class that simulates one of a set of noisy GPS receivers.
    % The running assumption is that all the receivers are (approximately) geographically 
    % co-located so that pseudorange measurements to the same satellite vehicle obtained 
    % by different receivers are strongly correlated.
    %
    % When computing a solution the position of each satellite vehicles is determined 
    % interpolating the precise orbits file (SP3) defined in params.gpsnoise.preciseorbitfile,
    % pseudorange errors are considered additive and modelled by a second order Gauss-Markov
    % process, the receiver position is computed using ordinary LS. 
    % Global variables are used to maintain the noise states shared between receivers. 
    %
    % This model is inspired to GPSPseudorangeGM but attempts to capture the empirical 
    % observation that the readings from commercial GPS unit are generally "smoother" than 
    % what generated by GPSPseudorangeGM.
    %
    % [1] J. Rankin, "An error model for sensor simulation GPS and differential GPS," IEEE 
    %     Position Location and Navigation Symposium, 1994, pp.260-266.
    %
    % GPSPseudorangeGM2 Methods:
    %    GPSSpaceSegmentGM2(objparams)- constructor
    %    update([])                 - propagates the noise state forward in time
    %
    
    properties (Access=private)
        tStart                        % simulation start GPS time  
        PR_BETA2                      % process time constant
        PR_BETA1                      % process time constant   
        PR_SIGMA                      % process standard deviation (from [1])  
    end
    
    methods
        
        function obj=GPSPseudorangeGM2(objparams)
            % constructs the object.
            % Loads and interpoates the satellites orbits and creates and initialises a
            % Gauss-Markov process for each of the GPS satellite vehicles.
            % These processes represent additive noise to the pseudorange measurement
            % of each satellite.
            %
            % Example:
            %
            %   obj=GPSPseudorangeGM2(objparams);
            %                objparams.dt - timestep of this object
            %                objparams.DT - global simulation timestep
            %                objparams.on - 1 if the object is active 
            %                objparams.seed - prng seed, random if 0 
            %                objparams.PR_BETA2 - process time constant
            %                objparams.PR_BETA1 - process time constant
            %                objparams.PR_SIGMA - process standard deviation 
            %                objparams.tStart - simulation start in GPS time
            %
            global state;
                        
            obj=obj@GPS(objparams);
            
            obj.originUTMcoords = objparams.originutmcoords;
            obj.tStart = objparams.tStart;
            obj.PR_BETA2 = objparams.PR_BETA2;
            obj.PR_BETA1 = objparams.PR_BETA1;
            obj.PR_SIGMA = objparams.PR_SIGMA; 
            obj.R_SIGMA = objparams.R_SIGMA;  
            
            obj.init(objparams);
            
            % pick randomly the satellites visible for this receiver
            obj.nsv = objparams.minmaxnumsv(1)...
                     +randi(obj.rStream,objparams.minmaxnumsv(2) ...
                     -objparams.minmaxnumsv(1));
            
            obj.svidx = zeros(1,obj.nsv);
            r = randperm(obj.rStream,state.sensors.gps.nsv);
            obj.svidx = r(1:obj.nsv);
            
            obj.setDt(params.sensors.gps.dt);
        end
                
        function obj = init(obj,objparams)
            % initialises the state of the noise process.
            % Creates and initialises a second order Gauss-Markov process for each of the GPS 
            % satellite vehicles. These processes represent additive noise to the pseudorange
            % measurement of each satellite.
            %
            % Example:
            %
            %   obj.init(objparams);
            %       objparams - gps parameters defined in general config file
            %
            global state;
            
            if(~exist('state.sensors.gps.exists','var'))
                
                % read in the precise satellite orbits
                state.sensors.gps.stdPe = readSP3(Orbits, objparams.preciseorbitfile);
                state.sensors.gps.stdPe.compute();
                
                state.sensors.gps.svs = objparams.svs;
                
                % for each of the possible svs we initialize the
                % common part of the pseudorange noise models                
                state.sensors.gps.nsv = length(objparams.svs);
                state.sensors.gps.prns=zeros(state.sensors.gps.nsv,1);
                state.gpsnoise.prns1 = zeros(state.gpsnoise.nsv,1);
                
                state.gpsnoise.betas2 = (1/obj.PR_BETA2)*ones(state.gpsnoise.nsv,1);
                state.gpsnoise.betas1 = (1/obj.PR_BETA1)*ones(state.gpsnoise.nsv,1);
                state.gpsnoise.w = obj.PR_SIGMA*ones(state.gpsnoise.nsv,1);
                
                state.sensors.gps.t = 0;                
                                
                state.sensors.gps.exists = 1;
            end 
        end
        
        function estimatedPosNED = getMeasurement(obj,truePosNED)
            % computes and returns a GPS estimate given the current noise free position
            % The method converts the current noiseless receiver position truePosNED, to ECEF
            % coordinates and given the current time, computes the satellite vehicles positions. 
            % For each satellite it then computes the pseudorange, to which the current 
            % noise is added together with a receiver dependent white noise component.
            % It uses LS to estimate the receiver location and returns it after converting
            % it to NED coordinates.
            %
            % Example:
            %
            %   estimatedPosNED = obj.compute(truePosNED)   
            %                     truePosNED - 3 by 1 vector [m] noiseless position
            %                     estimatedPosNED - 3 by 1 vector [m] estimated position
            %
            global state;
            
            r = rem(state.t,obj.dt);
            if((r<obj.TOL)||((obj.dt-r)<obj.TOL))
                
                truePosECEF = ned2ecef(truePosNED, obj.originUTMcoords);
                
                obs = zeros(obj.nsv,1);
                for i = 1:obj.nsv,
                    % compute pseudorange
                    obs(i,1) = norm(truePosECEF-state.gpsnoise.svspos(:,obj.svidx(i)))...
                              +state.gpsnoise.prns(obj.svidx(i))...
                              +obj.R_SIGMA*randn(1,1);
                end
                
                % ordinary lest square solution initialised at the previous solution
                p = [obj.estimatedPosNED;0];
                for iter = 1:5 % even 3 iterations should do since we prime it
                    A = zeros(obj.nsv,4);
                    omc = zeros(obj.nsv,1); % observed minus computed observation
                    for i = 1:obj.nsv,
                        X = state.gpsnoise.svspos(:,obj.svidx(i));
                        omc(i,:) = obs(i)-norm(X-p(1:3),'fro')-p(4);
                        A(i,:) = [(-(X(1)-p(1)))/obs(i), (-(X(2)-p(2)))/obs(i), (-(X(3)-p(3)))/obs(i), 1];
                    end % i
                    x = A\omc;
                    p = p+x;
                end % iter
                
                obj.estimatedPosNED = ecef2ned(p(1:3), obj.originUTMcoords);
            else 
                % no need to update return last measurement
            end
            
            estimatedPosNED = obj.estimatedPosNED;            
        end
        
    end
    
    methods (Access=protected)
        
        function obj=update(obj,~)
            % propagates the noise state forward in time
            %
            % Note:
            %  this method is called automatically by the step() of the Steppable parent 
            %  class and should not be called directly.
            %
            global state params;
            
            % we update the noise only once per timestep
            if(state.gpsnoise.t ~= (params.gpsnoise.tStart+state.t))
                
                state.gpsnoise.t = (params.gpsnoise.tStart+state.t);
                
                % update noise states
                state.gpsnoise.prns = state.gpsnoise.prns.*state.gpsnoise.betas1 + state.gpsnoise.prns1;
                state.gpsnoise.prns1 = state.gpsnoise.prns1.*exp(-state.gpsnoise.betas2*params.dt)...
                                      +state.gpsnoise.w.*randn(obj.rStream,state.gpsnoise.nsv,1);

                state.gpsnoise.svspos=zeros(3,state.gpsnoise.nsv);
                for j = 1:state.gpsnoise.nsv,
                    %compute sv positions
                    state.gpsnoise.svspos(:,j) = getSatCoord(state.gpsnoise.stdPe,...
                                                 state.gpsnoise.svs(j),state.gpsnoise.t);
                end
            end
        end
    end
    
end
